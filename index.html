<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Buffer-overflow-cases by ytyxbgl</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Buffer-overflow-cases</h1>
        <p></p>

        <p class="view"><a href="https://github.com/ytyxbgl/Buffer-Overflow-Cases">View the Project on GitHub <small>ytyxbgl/Buffer-Overflow-Cases</small></a></p>


        <ul>
          <li><a href="https://github.com/ytyxbgl/Buffer-Overflow-Cases/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/ytyxbgl/Buffer-Overflow-Cases/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/ytyxbgl/Buffer-Overflow-Cases">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>

<p>This page is still under construction. </p>
<p>This is the homepage of our recent work on buffer overflow. </p>
        <h3>
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introduction</h3>

<p>Buffer overﬂow has become one of the best known types of software security vulnerabilities. Although researchers have proposed various techniques for buffer overﬂow detection, buffer overﬂow attacks against both legacy and newlydeployed software systems are still quite prevalent. According to the statistics by Common Vulnerabilities and Exposures (CVE), buffer overﬂow accounts for 14.6% of all software vulnerabilities since 1999. With Code Execution for 31.4% and Denial of Service for 21.5%, buffer overﬂow is now the third most popular type of vulnerabilities. Software containing buffer overﬂow bugs can lead to system crash, denial of service, or loss of control to external attackers, leading to disastrous consequences.</p>

<p> Currently, there are two general approaches to identifying buffer overﬂow vulnerabilities: static program analysis and dynamic testing. The dynamic testing approach inserts special code into software so that buffer overﬂow occurrences can be detected and properly processed such as terminating software execution. The key advantage of such schemes is that they rarely have false positives because they have software execution information. The key limitation of such schemes is that they usually incur an excessive amount of performance overhead because the inserted code needs to be executed for each buffer operation and function call.</p>

<p>The static program analysis approach scans software source code to discover the code segments that are possibly vulnerable to buffer overﬂow attacks. Each vulnerability warning needs to be manually inspected to check whether each warning is indeed a true vulnerability. The key advantage of such schemes is that buffer overﬂow vulnerabilities can be discovered and ﬁxed before software deployment. The key limitation of such existing schemes is that the reported buffer overﬂow vulnerabilities contain too many false positives fundamentally due to the lack of software execution information and each false positive wastes a huge amount of human effort on manual source code inspection. </p>

<p>To date, there are few studies on the effectiveness and efﬁciency of state-of-the-art static buffer overﬂow detection techniques. In our work,  we perform an in-depth quantitative and qualitative study on static buffer overﬂow detection. More speciﬁcally, we obtain both the buggy and ﬁxed versions of 100 buffer overﬂow bugs from 63 real-world projects according to the buffer overﬂow reports in CVE. Then, quantitatively, we apply Checkmarx, Fortify, and Splint to all the buggy versions to investigate their false negatives, and also apply them to all the ﬁxed versions to investigate their false positives.  We also qualitatively investigate the root reasons for the false-negatives and false-positives of studied techniques to guide the design and implementation of more advanced buffer overﬂow detection techniques. Finally, we also categorized the
manual repair patterns of buffer overﬂow repairs to guide both the manual and automated repair for buffer overﬂow. </p>

<h3>
<a id="subject-system" class="anchor" href="#subject-system" aria-hidden="true"><span class="octicon octicon-link"></span></a>Subject System</h3>

<p>To enable objective selection of the buffer overﬂow bugs, we randomly selected bugs within the buffer overﬂow category from the CVE website. For each selected bug, we discard it if the corresponding project is not open-source. We continue this process until we ﬁnd 100 qualiﬁed bugs. For each bug, we obtain both the buggy version and repaired version for analysis and inspection.  In total, we inspected 100 buffer overﬂow bugs from the version history of 63 real-world projects, totalling 28000 KLoC, ranging from CVE-1999 to CVE-2014.
You can find all their source code <a href="https://github.com/ytyxbgl/Buffer-Overflow-Cases/tree/gh-pages/files/bufferoverflowcases"> here</a>. </p>

<h3>
<a id="experiment" class="anchor" href="#experiment" aria-hidden="true"><span class="octicon octicon-link"></span></a>Experiment</h3>

<p>For each buffer overﬂow bug, the following steps are performed: First, we obtain the bug report from CVE. If the bug does not occur in open-source project, we will continue to another bug. Then, we get both the faulty and ﬁxed version of the bug from code repository of the corresponding open-source project. Second, we apply all the studied techniques to analyze the corresponding faulty version to ﬁnd the bugs that cannot be detected for each technique, i.e., false-negatives. In addition, we record the analysis time for each tool. Third, we apply all the studied techniques to analyze the corresponding ﬁxed version to ﬁnd the ﬁxed bugs that are still identiﬁed as bugs, i.e., false-positives. In addition, we record the analysis time for each tool. Finally,we perform qualitative analysis on each bug:(1)we record the detailed bug information (e.g., the API involved); (2)we categorize the manual ﬁx pattern for the bug. We repeat the steps for all the 100 studied bugs. </p>

<p>You can find <a href="">a docx file</a> in which we briefly explain the reason why it is a buffer overflow bug for each bug, and <a href="">a xlsx file</a> where we record detailed information about each bug.</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/ytyxbgl">ytyxbgl</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
